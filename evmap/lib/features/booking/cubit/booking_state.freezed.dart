// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'booking_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$BookingState {
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookingStateCopyWith<$Res> {
  factory $BookingStateCopyWith(
          BookingState value, $Res Function(BookingState) then) =
      _$BookingStateCopyWithImpl<$Res, BookingState>;
}

/// @nodoc
class _$BookingStateCopyWithImpl<$Res, $Val extends BookingState>
    implements $BookingStateCopyWith<$Res> {
  _$BookingStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BookingNothingCopyWith<$Res> {
  factory _$$BookingNothingCopyWith(
          _$BookingNothing value, $Res Function(_$BookingNothing) then) =
      __$$BookingNothingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookingNothingCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingNothing>
    implements _$$BookingNothingCopyWith<$Res> {
  __$$BookingNothingCopyWithImpl(
      _$BookingNothing _value, $Res Function(_$BookingNothing) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BookingNothing implements BookingNothing {
  const _$BookingNothing();

  @override
  String toString() {
    return 'BookingState.nothing()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return nothing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (nothing != null) {
      return nothing();
    }
    return orElse();
  }
}

abstract class BookingNothing implements BookingState {
  const factory BookingNothing() = _$BookingNothing;
}

/// @nodoc
abstract class _$$BookingLoadingCopyWith<$Res> {
  factory _$$BookingLoadingCopyWith(
          _$BookingLoading value, $Res Function(_$BookingLoading) then) =
      __$$BookingLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookingLoadingCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingLoading>
    implements _$$BookingLoadingCopyWith<$Res> {
  __$$BookingLoadingCopyWithImpl(
      _$BookingLoading _value, $Res Function(_$BookingLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BookingLoading implements BookingLoading {
  const _$BookingLoading();

  @override
  String toString() {
    return 'BookingState.loading()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }
}

abstract class BookingLoading implements BookingState {
  const factory BookingLoading() = _$BookingLoading;
}

/// @nodoc
abstract class _$$BookingLoadingScreenCopyWith<$Res> {
  factory _$$BookingLoadingScreenCopyWith(_$BookingLoadingScreen value,
          $Res Function(_$BookingLoadingScreen) then) =
      __$$BookingLoadingScreenCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookingLoadingScreenCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingLoadingScreen>
    implements _$$BookingLoadingScreenCopyWith<$Res> {
  __$$BookingLoadingScreenCopyWithImpl(_$BookingLoadingScreen _value,
      $Res Function(_$BookingLoadingScreen) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BookingLoadingScreen implements BookingLoadingScreen {
  const _$BookingLoadingScreen();

  @override
  String toString() {
    return 'BookingState.loadingScreen()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return loadingScreen?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (loadingScreen != null) {
      return loadingScreen();
    }
    return orElse();
  }
}

abstract class BookingLoadingScreen implements BookingState {
  const factory BookingLoadingScreen() = _$BookingLoadingScreen;
}

/// @nodoc
abstract class _$$BookingReasionLoggedCopyWith<$Res> {
  factory _$$BookingReasionLoggedCopyWith(_$BookingReasionLogged value,
          $Res Function(_$BookingReasionLogged) then) =
      __$$BookingReasionLoggedCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ReasonModel> data});
}

/// @nodoc
class __$$BookingReasionLoggedCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingReasionLogged>
    implements _$$BookingReasionLoggedCopyWith<$Res> {
  __$$BookingReasionLoggedCopyWithImpl(_$BookingReasionLogged _value,
      $Res Function(_$BookingReasionLogged) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$BookingReasionLogged(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<ReasonModel>,
    ));
  }
}

/// @nodoc

class _$BookingReasionLogged implements BookingReasionLogged {
  const _$BookingReasionLogged({required final List<ReasonModel> data})
      : _data = data;

  final List<ReasonModel> _data;
  @override
  List<ReasonModel> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'BookingState.reasonLogged(data: $data)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingReasionLoggedCopyWith<_$BookingReasionLogged> get copyWith =>
      __$$BookingReasionLoggedCopyWithImpl<_$BookingReasionLogged>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return reasonLogged?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (reasonLogged != null) {
      return reasonLogged(data);
    }
    return orElse();
  }
}

abstract class BookingReasionLogged implements BookingState {
  const factory BookingReasionLogged({required final List<ReasonModel> data}) =
      _$BookingReasionLogged;

  List<ReasonModel> get data;
  @JsonKey(ignore: true)
  _$$BookingReasionLoggedCopyWith<_$BookingReasionLogged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ReservationHistoryLoggedCopyWith<$Res> {
  factory _$$ReservationHistoryLoggedCopyWith(_$ReservationHistoryLogged value,
          $Res Function(_$ReservationHistoryLogged) then) =
      __$$ReservationHistoryLoggedCopyWithImpl<$Res>;
  @useResult
  $Res call({List<BookingModel> data, bool? isFinish});
}

/// @nodoc
class __$$ReservationHistoryLoggedCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$ReservationHistoryLogged>
    implements _$$ReservationHistoryLoggedCopyWith<$Res> {
  __$$ReservationHistoryLoggedCopyWithImpl(_$ReservationHistoryLogged _value,
      $Res Function(_$ReservationHistoryLogged) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? isFinish = freezed,
  }) {
    return _then(_$ReservationHistoryLogged(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<BookingModel>,
      isFinish: freezed == isFinish
          ? _value.isFinish
          : isFinish // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$ReservationHistoryLogged implements ReservationHistoryLogged {
  const _$ReservationHistoryLogged(
      {required final List<BookingModel> data, this.isFinish})
      : _data = data;

  final List<BookingModel> _data;
  @override
  List<BookingModel> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  final bool? isFinish;

  @override
  String toString() {
    return 'BookingState.reservationHistoryLogged(data: $data, isFinish: $isFinish)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReservationHistoryLoggedCopyWith<_$ReservationHistoryLogged>
      get copyWith =>
          __$$ReservationHistoryLoggedCopyWithImpl<_$ReservationHistoryLogged>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return reservationHistoryLogged?.call(data, isFinish);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (reservationHistoryLogged != null) {
      return reservationHistoryLogged(data, isFinish);
    }
    return orElse();
  }
}

abstract class ReservationHistoryLogged implements BookingState {
  const factory ReservationHistoryLogged(
      {required final List<BookingModel> data,
      final bool? isFinish}) = _$ReservationHistoryLogged;

  List<BookingModel> get data;
  bool? get isFinish;
  @JsonKey(ignore: true)
  _$$ReservationHistoryLoggedCopyWith<_$ReservationHistoryLogged>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookingSlotsLoggedCopyWith<$Res> {
  factory _$$BookingSlotsLoggedCopyWith(_$BookingSlotsLogged value,
          $Res Function(_$BookingSlotsLogged) then) =
      __$$BookingSlotsLoggedCopyWithImpl<$Res>;
  @useResult
  $Res call({List<SlotDataModel> data});
}

/// @nodoc
class __$$BookingSlotsLoggedCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingSlotsLogged>
    implements _$$BookingSlotsLoggedCopyWith<$Res> {
  __$$BookingSlotsLoggedCopyWithImpl(
      _$BookingSlotsLogged _value, $Res Function(_$BookingSlotsLogged) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$BookingSlotsLogged(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<SlotDataModel>,
    ));
  }
}

/// @nodoc

class _$BookingSlotsLogged implements BookingSlotsLogged {
  const _$BookingSlotsLogged({required final List<SlotDataModel> data})
      : _data = data;

  final List<SlotDataModel> _data;
  @override
  List<SlotDataModel> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'BookingState.slotsLogged(data: $data)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingSlotsLoggedCopyWith<_$BookingSlotsLogged> get copyWith =>
      __$$BookingSlotsLoggedCopyWithImpl<_$BookingSlotsLogged>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return slotsLogged?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (slotsLogged != null) {
      return slotsLogged(data);
    }
    return orElse();
  }
}

abstract class BookingSlotsLogged implements BookingState {
  const factory BookingSlotsLogged({required final List<SlotDataModel> data}) =
      _$BookingSlotsLogged;

  List<SlotDataModel> get data;
  @JsonKey(ignore: true)
  _$$BookingSlotsLoggedCopyWith<_$BookingSlotsLogged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookingSuccessCopyWith<$Res> {
  factory _$$BookingSuccessCopyWith(
          _$BookingSuccess value, $Res Function(_$BookingSuccess) then) =
      __$$BookingSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({SlotDataModel? detail});
}

/// @nodoc
class __$$BookingSuccessCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingSuccess>
    implements _$$BookingSuccessCopyWith<$Res> {
  __$$BookingSuccessCopyWithImpl(
      _$BookingSuccess _value, $Res Function(_$BookingSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? detail = freezed,
  }) {
    return _then(_$BookingSuccess(
      detail: freezed == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as SlotDataModel?,
    ));
  }
}

/// @nodoc

class _$BookingSuccess implements BookingSuccess {
  const _$BookingSuccess({this.detail});

  @override
  final SlotDataModel? detail;

  @override
  String toString() {
    return 'BookingState.bookingSuccess(detail: $detail)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingSuccessCopyWith<_$BookingSuccess> get copyWith =>
      __$$BookingSuccessCopyWithImpl<_$BookingSuccess>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return bookingSuccess?.call(detail);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (bookingSuccess != null) {
      return bookingSuccess(detail);
    }
    return orElse();
  }
}

abstract class BookingSuccess implements BookingState {
  const factory BookingSuccess({final SlotDataModel? detail}) =
      _$BookingSuccess;

  SlotDataModel? get detail;
  @JsonKey(ignore: true)
  _$$BookingSuccessCopyWith<_$BookingSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookingCancelCopyWith<$Res> {
  factory _$$BookingCancelCopyWith(
          _$BookingCancel value, $Res Function(_$BookingCancel) then) =
      __$$BookingCancelCopyWithImpl<$Res>;
  @useResult
  $Res call({num? idBooking});
}

/// @nodoc
class __$$BookingCancelCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingCancel>
    implements _$$BookingCancelCopyWith<$Res> {
  __$$BookingCancelCopyWithImpl(
      _$BookingCancel _value, $Res Function(_$BookingCancel) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idBooking = freezed,
  }) {
    return _then(_$BookingCancel(
      idBooking: freezed == idBooking
          ? _value.idBooking
          : idBooking // ignore: cast_nullable_to_non_nullable
              as num?,
    ));
  }
}

/// @nodoc

class _$BookingCancel implements BookingCancel {
  const _$BookingCancel({this.idBooking});

  @override
  final num? idBooking;

  @override
  String toString() {
    return 'BookingState.bookingCancel(idBooking: $idBooking)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingCancelCopyWith<_$BookingCancel> get copyWith =>
      __$$BookingCancelCopyWithImpl<_$BookingCancel>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return bookingCancel?.call(idBooking);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (bookingCancel != null) {
      return bookingCancel(idBooking);
    }
    return orElse();
  }
}

abstract class BookingCancel implements BookingState {
  const factory BookingCancel({final num? idBooking}) = _$BookingCancel;

  num? get idBooking;
  @JsonKey(ignore: true)
  _$$BookingCancelCopyWith<_$BookingCancel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookingErrorCopyWith<$Res> {
  factory _$$BookingErrorCopyWith(
          _$BookingError value, $Res Function(_$BookingError) then) =
      __$$BookingErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String? error});
}

/// @nodoc
class __$$BookingErrorCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingError>
    implements _$$BookingErrorCopyWith<$Res> {
  __$$BookingErrorCopyWithImpl(
      _$BookingError _value, $Res Function(_$BookingError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(_$BookingError(
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$BookingError implements BookingError {
  const _$BookingError({this.error});

  @override
  final String? error;

  @override
  String toString() {
    return 'BookingState.error(error: $error)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingErrorCopyWith<_$BookingError> get copyWith =>
      __$$BookingErrorCopyWithImpl<_$BookingError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }
}

abstract class BookingError implements BookingState {
  const factory BookingError({final String? error}) = _$BookingError;

  String? get error;
  @JsonKey(ignore: true)
  _$$BookingErrorCopyWith<_$BookingError> get copyWith =>
      throw _privateConstructorUsedError;
}

// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'booking_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$BookingState {
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BookingStateCopyWith<$Res> {
  factory $BookingStateCopyWith(
          BookingState value, $Res Function(BookingState) then) =
      _$BookingStateCopyWithImpl<$Res, BookingState>;
}

/// @nodoc
class _$BookingStateCopyWithImpl<$Res, $Val extends BookingState>
    implements $BookingStateCopyWith<$Res> {
  _$BookingStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$BookingNothingImplCopyWith<$Res> {
  factory _$$BookingNothingImplCopyWith(_$BookingNothingImpl value,
          $Res Function(_$BookingNothingImpl) then) =
      __$$BookingNothingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookingNothingImplCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingNothingImpl>
    implements _$$BookingNothingImplCopyWith<$Res> {
  __$$BookingNothingImplCopyWithImpl(
      _$BookingNothingImpl _value, $Res Function(_$BookingNothingImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BookingNothingImpl implements BookingNothing {
  const _$BookingNothingImpl();

  @override
  String toString() {
    return 'BookingState.nothing()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return nothing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (nothing != null) {
      return nothing();
    }
    return orElse();
  }
}

abstract class BookingNothing implements BookingState {
  const factory BookingNothing() = _$BookingNothingImpl;
}

/// @nodoc
abstract class _$$BookingLoadingImplCopyWith<$Res> {
  factory _$$BookingLoadingImplCopyWith(_$BookingLoadingImpl value,
          $Res Function(_$BookingLoadingImpl) then) =
      __$$BookingLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookingLoadingImplCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingLoadingImpl>
    implements _$$BookingLoadingImplCopyWith<$Res> {
  __$$BookingLoadingImplCopyWithImpl(
      _$BookingLoadingImpl _value, $Res Function(_$BookingLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BookingLoadingImpl implements BookingLoading {
  const _$BookingLoadingImpl();

  @override
  String toString() {
    return 'BookingState.loading()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }
}

abstract class BookingLoading implements BookingState {
  const factory BookingLoading() = _$BookingLoadingImpl;
}

/// @nodoc
abstract class _$$BookingLoadingScreenImplCopyWith<$Res> {
  factory _$$BookingLoadingScreenImplCopyWith(_$BookingLoadingScreenImpl value,
          $Res Function(_$BookingLoadingScreenImpl) then) =
      __$$BookingLoadingScreenImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookingLoadingScreenImplCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingLoadingScreenImpl>
    implements _$$BookingLoadingScreenImplCopyWith<$Res> {
  __$$BookingLoadingScreenImplCopyWithImpl(_$BookingLoadingScreenImpl _value,
      $Res Function(_$BookingLoadingScreenImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BookingLoadingScreenImpl implements BookingLoadingScreen {
  const _$BookingLoadingScreenImpl();

  @override
  String toString() {
    return 'BookingState.loadingScreen()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return loadingScreen?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (loadingScreen != null) {
      return loadingScreen();
    }
    return orElse();
  }
}

abstract class BookingLoadingScreen implements BookingState {
  const factory BookingLoadingScreen() = _$BookingLoadingScreenImpl;
}

/// @nodoc
abstract class _$$BookingReasionLoggedImplCopyWith<$Res> {
  factory _$$BookingReasionLoggedImplCopyWith(_$BookingReasionLoggedImpl value,
          $Res Function(_$BookingReasionLoggedImpl) then) =
      __$$BookingReasionLoggedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ReasonModel> data});
}

/// @nodoc
class __$$BookingReasionLoggedImplCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingReasionLoggedImpl>
    implements _$$BookingReasionLoggedImplCopyWith<$Res> {
  __$$BookingReasionLoggedImplCopyWithImpl(_$BookingReasionLoggedImpl _value,
      $Res Function(_$BookingReasionLoggedImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$BookingReasionLoggedImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<ReasonModel>,
    ));
  }
}

/// @nodoc

class _$BookingReasionLoggedImpl implements BookingReasionLogged {
  const _$BookingReasionLoggedImpl({required final List<ReasonModel> data})
      : _data = data;

  final List<ReasonModel> _data;
  @override
  List<ReasonModel> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'BookingState.reasonLogged(data: $data)';
  }

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingReasionLoggedImplCopyWith<_$BookingReasionLoggedImpl>
      get copyWith =>
          __$$BookingReasionLoggedImplCopyWithImpl<_$BookingReasionLoggedImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return reasonLogged?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (reasonLogged != null) {
      return reasonLogged(data);
    }
    return orElse();
  }
}

abstract class BookingReasionLogged implements BookingState {
  const factory BookingReasionLogged({required final List<ReasonModel> data}) =
      _$BookingReasionLoggedImpl;

  List<ReasonModel> get data;

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookingReasionLoggedImplCopyWith<_$BookingReasionLoggedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ReservationHistoryLoggedImplCopyWith<$Res> {
  factory _$$ReservationHistoryLoggedImplCopyWith(
          _$ReservationHistoryLoggedImpl value,
          $Res Function(_$ReservationHistoryLoggedImpl) then) =
      __$$ReservationHistoryLoggedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<BookingModel> data, bool? isFinish});
}

/// @nodoc
class __$$ReservationHistoryLoggedImplCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$ReservationHistoryLoggedImpl>
    implements _$$ReservationHistoryLoggedImplCopyWith<$Res> {
  __$$ReservationHistoryLoggedImplCopyWithImpl(
      _$ReservationHistoryLoggedImpl _value,
      $Res Function(_$ReservationHistoryLoggedImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
    Object? isFinish = freezed,
  }) {
    return _then(_$ReservationHistoryLoggedImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<BookingModel>,
      isFinish: freezed == isFinish
          ? _value.isFinish
          : isFinish // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$ReservationHistoryLoggedImpl implements ReservationHistoryLogged {
  const _$ReservationHistoryLoggedImpl(
      {required final List<BookingModel> data, this.isFinish})
      : _data = data;

  final List<BookingModel> _data;
  @override
  List<BookingModel> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  final bool? isFinish;

  @override
  String toString() {
    return 'BookingState.reservationHistoryLogged(data: $data, isFinish: $isFinish)';
  }

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ReservationHistoryLoggedImplCopyWith<_$ReservationHistoryLoggedImpl>
      get copyWith => __$$ReservationHistoryLoggedImplCopyWithImpl<
          _$ReservationHistoryLoggedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return reservationHistoryLogged?.call(data, isFinish);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (reservationHistoryLogged != null) {
      return reservationHistoryLogged(data, isFinish);
    }
    return orElse();
  }
}

abstract class ReservationHistoryLogged implements BookingState {
  const factory ReservationHistoryLogged(
      {required final List<BookingModel> data,
      final bool? isFinish}) = _$ReservationHistoryLoggedImpl;

  List<BookingModel> get data;
  bool? get isFinish;

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ReservationHistoryLoggedImplCopyWith<_$ReservationHistoryLoggedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookingSlotsLoggedImplCopyWith<$Res> {
  factory _$$BookingSlotsLoggedImplCopyWith(_$BookingSlotsLoggedImpl value,
          $Res Function(_$BookingSlotsLoggedImpl) then) =
      __$$BookingSlotsLoggedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<SlotDataModel> data});
}

/// @nodoc
class __$$BookingSlotsLoggedImplCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingSlotsLoggedImpl>
    implements _$$BookingSlotsLoggedImplCopyWith<$Res> {
  __$$BookingSlotsLoggedImplCopyWithImpl(_$BookingSlotsLoggedImpl _value,
      $Res Function(_$BookingSlotsLoggedImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = null,
  }) {
    return _then(_$BookingSlotsLoggedImpl(
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<SlotDataModel>,
    ));
  }
}

/// @nodoc

class _$BookingSlotsLoggedImpl implements BookingSlotsLogged {
  const _$BookingSlotsLoggedImpl({required final List<SlotDataModel> data})
      : _data = data;

  final List<SlotDataModel> _data;
  @override
  List<SlotDataModel> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  String toString() {
    return 'BookingState.slotsLogged(data: $data)';
  }

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingSlotsLoggedImplCopyWith<_$BookingSlotsLoggedImpl> get copyWith =>
      __$$BookingSlotsLoggedImplCopyWithImpl<_$BookingSlotsLoggedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return slotsLogged?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (slotsLogged != null) {
      return slotsLogged(data);
    }
    return orElse();
  }
}

abstract class BookingSlotsLogged implements BookingState {
  const factory BookingSlotsLogged({required final List<SlotDataModel> data}) =
      _$BookingSlotsLoggedImpl;

  List<SlotDataModel> get data;

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookingSlotsLoggedImplCopyWith<_$BookingSlotsLoggedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookingSuccessImplCopyWith<$Res> {
  factory _$$BookingSuccessImplCopyWith(_$BookingSuccessImpl value,
          $Res Function(_$BookingSuccessImpl) then) =
      __$$BookingSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SlotDataModel? detail});
}

/// @nodoc
class __$$BookingSuccessImplCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingSuccessImpl>
    implements _$$BookingSuccessImplCopyWith<$Res> {
  __$$BookingSuccessImplCopyWithImpl(
      _$BookingSuccessImpl _value, $Res Function(_$BookingSuccessImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? detail = freezed,
  }) {
    return _then(_$BookingSuccessImpl(
      detail: freezed == detail
          ? _value.detail
          : detail // ignore: cast_nullable_to_non_nullable
              as SlotDataModel?,
    ));
  }
}

/// @nodoc

class _$BookingSuccessImpl implements BookingSuccess {
  const _$BookingSuccessImpl({this.detail});

  @override
  final SlotDataModel? detail;

  @override
  String toString() {
    return 'BookingState.bookingSuccess(detail: $detail)';
  }

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingSuccessImplCopyWith<_$BookingSuccessImpl> get copyWith =>
      __$$BookingSuccessImplCopyWithImpl<_$BookingSuccessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return bookingSuccess?.call(detail);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (bookingSuccess != null) {
      return bookingSuccess(detail);
    }
    return orElse();
  }
}

abstract class BookingSuccess implements BookingState {
  const factory BookingSuccess({final SlotDataModel? detail}) =
      _$BookingSuccessImpl;

  SlotDataModel? get detail;

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookingSuccessImplCopyWith<_$BookingSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookingCancelImplCopyWith<$Res> {
  factory _$$BookingCancelImplCopyWith(
          _$BookingCancelImpl value, $Res Function(_$BookingCancelImpl) then) =
      __$$BookingCancelImplCopyWithImpl<$Res>;
  @useResult
  $Res call({num? idBooking});
}

/// @nodoc
class __$$BookingCancelImplCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingCancelImpl>
    implements _$$BookingCancelImplCopyWith<$Res> {
  __$$BookingCancelImplCopyWithImpl(
      _$BookingCancelImpl _value, $Res Function(_$BookingCancelImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? idBooking = freezed,
  }) {
    return _then(_$BookingCancelImpl(
      idBooking: freezed == idBooking
          ? _value.idBooking
          : idBooking // ignore: cast_nullable_to_non_nullable
              as num?,
    ));
  }
}

/// @nodoc

class _$BookingCancelImpl implements BookingCancel {
  const _$BookingCancelImpl({this.idBooking});

  @override
  final num? idBooking;

  @override
  String toString() {
    return 'BookingState.bookingCancel(idBooking: $idBooking)';
  }

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingCancelImplCopyWith<_$BookingCancelImpl> get copyWith =>
      __$$BookingCancelImplCopyWithImpl<_$BookingCancelImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return bookingCancel?.call(idBooking);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (bookingCancel != null) {
      return bookingCancel(idBooking);
    }
    return orElse();
  }
}

abstract class BookingCancel implements BookingState {
  const factory BookingCancel({final num? idBooking}) = _$BookingCancelImpl;

  num? get idBooking;

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookingCancelImplCopyWith<_$BookingCancelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookingErrorImplCopyWith<$Res> {
  factory _$$BookingErrorImplCopyWith(
          _$BookingErrorImpl value, $Res Function(_$BookingErrorImpl) then) =
      __$$BookingErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String? error});
}

/// @nodoc
class __$$BookingErrorImplCopyWithImpl<$Res>
    extends _$BookingStateCopyWithImpl<$Res, _$BookingErrorImpl>
    implements _$$BookingErrorImplCopyWith<$Res> {
  __$$BookingErrorImplCopyWithImpl(
      _$BookingErrorImpl _value, $Res Function(_$BookingErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
  }) {
    return _then(_$BookingErrorImpl(
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$BookingErrorImpl implements BookingError {
  const _$BookingErrorImpl({this.error});

  @override
  final String? error;

  @override
  String toString() {
    return 'BookingState.error(error: $error)';
  }

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookingErrorImplCopyWith<_$BookingErrorImpl> get copyWith =>
      __$$BookingErrorImplCopyWithImpl<_$BookingErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? nothing,
    TResult? Function()? loading,
    TResult? Function()? loadingScreen,
    TResult? Function(List<ReasonModel> data)? reasonLogged,
    TResult? Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult? Function(List<SlotDataModel> data)? slotsLogged,
    TResult? Function(SlotDataModel? detail)? bookingSuccess,
    TResult? Function(num? idBooking)? bookingCancel,
    TResult? Function(String? error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? nothing,
    TResult Function()? loading,
    TResult Function()? loadingScreen,
    TResult Function(List<ReasonModel> data)? reasonLogged,
    TResult Function(List<BookingModel> data, bool? isFinish)?
        reservationHistoryLogged,
    TResult Function(List<SlotDataModel> data)? slotsLogged,
    TResult Function(SlotDataModel? detail)? bookingSuccess,
    TResult Function(num? idBooking)? bookingCancel,
    TResult Function(String? error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }
}

abstract class BookingError implements BookingState {
  const factory BookingError({final String? error}) = _$BookingErrorImpl;

  String? get error;

  /// Create a copy of BookingState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookingErrorImplCopyWith<_$BookingErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

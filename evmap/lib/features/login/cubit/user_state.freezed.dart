// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$UserState {
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? loading,
    TResult? Function()? logged,
    TResult? Function()? registerLogged,
    TResult? Function()? logout,
    TResult? Function()? passwordUpdated,
    TResult? Function(String? error, List<String>? errors, Object? data)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? registerLogged,
    TResult Function()? logout,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserStateCopyWith<$Res> {
  factory $UserStateCopyWith(UserState value, $Res Function(UserState) then) =
      _$UserStateCopyWithImpl<$Res, UserState>;
}

/// @nodoc
class _$UserStateCopyWithImpl<$Res, $Val extends UserState>
    implements $UserStateCopyWith<$Res> {
  _$UserStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_UserStateCopyWith<$Res> {
  factory _$$_UserStateCopyWith(
          _$_UserState value, $Res Function(_$_UserState) then) =
      __$$_UserStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_UserStateCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$_UserState>
    implements _$$_UserStateCopyWith<$Res> {
  __$$_UserStateCopyWithImpl(
      _$_UserState _value, $Res Function(_$_UserState) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_UserState implements _UserState {
  const _$_UserState();

  @override
  String toString() {
    return 'UserState()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? loading,
    TResult? Function()? logged,
    TResult? Function()? registerLogged,
    TResult? Function()? logout,
    TResult? Function()? passwordUpdated,
    TResult? Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return $default?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? registerLogged,
    TResult Function()? logout,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if ($default != null) {
      return $default();
    }
    return orElse();
  }
}

abstract class _UserState implements UserState {
  const factory _UserState() = _$_UserState;
}

/// @nodoc
abstract class _$$UserLoadingCopyWith<$Res> {
  factory _$$UserLoadingCopyWith(
          _$UserLoading value, $Res Function(_$UserLoading) then) =
      __$$UserLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserLoadingCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$UserLoading>
    implements _$$UserLoadingCopyWith<$Res> {
  __$$UserLoadingCopyWithImpl(
      _$UserLoading _value, $Res Function(_$UserLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserLoading implements UserLoading {
  const _$UserLoading();

  @override
  String toString() {
    return 'UserState.loading()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? loading,
    TResult? Function()? logged,
    TResult? Function()? registerLogged,
    TResult? Function()? logout,
    TResult? Function()? passwordUpdated,
    TResult? Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? registerLogged,
    TResult Function()? logout,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }
}

abstract class UserLoading implements UserState {
  const factory UserLoading() = _$UserLoading;
}

/// @nodoc
abstract class _$$UserLoggedCopyWith<$Res> {
  factory _$$UserLoggedCopyWith(
          _$UserLogged value, $Res Function(_$UserLogged) then) =
      __$$UserLoggedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserLoggedCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$UserLogged>
    implements _$$UserLoggedCopyWith<$Res> {
  __$$UserLoggedCopyWithImpl(
      _$UserLogged _value, $Res Function(_$UserLogged) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserLogged implements UserLogged {
  const _$UserLogged();

  @override
  String toString() {
    return 'UserState.logged()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? loading,
    TResult? Function()? logged,
    TResult? Function()? registerLogged,
    TResult? Function()? logout,
    TResult? Function()? passwordUpdated,
    TResult? Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return logged?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? registerLogged,
    TResult Function()? logout,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (logged != null) {
      return logged();
    }
    return orElse();
  }
}

abstract class UserLogged implements UserState {
  const factory UserLogged() = _$UserLogged;
}

/// @nodoc
abstract class _$$UserRegisterLoggedCopyWith<$Res> {
  factory _$$UserRegisterLoggedCopyWith(_$UserRegisterLogged value,
          $Res Function(_$UserRegisterLogged) then) =
      __$$UserRegisterLoggedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserRegisterLoggedCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$UserRegisterLogged>
    implements _$$UserRegisterLoggedCopyWith<$Res> {
  __$$UserRegisterLoggedCopyWithImpl(
      _$UserRegisterLogged _value, $Res Function(_$UserRegisterLogged) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserRegisterLogged implements UserRegisterLogged {
  const _$UserRegisterLogged();

  @override
  String toString() {
    return 'UserState.registerLogged()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? loading,
    TResult? Function()? logged,
    TResult? Function()? registerLogged,
    TResult? Function()? logout,
    TResult? Function()? passwordUpdated,
    TResult? Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return registerLogged?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? registerLogged,
    TResult Function()? logout,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (registerLogged != null) {
      return registerLogged();
    }
    return orElse();
  }
}

abstract class UserRegisterLogged implements UserState {
  const factory UserRegisterLogged() = _$UserRegisterLogged;
}

/// @nodoc
abstract class _$$UserLogoutCopyWith<$Res> {
  factory _$$UserLogoutCopyWith(
          _$UserLogout value, $Res Function(_$UserLogout) then) =
      __$$UserLogoutCopyWithImpl<$Res>;
}

/// @nodoc
class __$$UserLogoutCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$UserLogout>
    implements _$$UserLogoutCopyWith<$Res> {
  __$$UserLogoutCopyWithImpl(
      _$UserLogout _value, $Res Function(_$UserLogout) _then)
      : super(_value, _then);
}

/// @nodoc

class _$UserLogout implements UserLogout {
  const _$UserLogout();

  @override
  String toString() {
    return 'UserState.logout()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? loading,
    TResult? Function()? logged,
    TResult? Function()? registerLogged,
    TResult? Function()? logout,
    TResult? Function()? passwordUpdated,
    TResult? Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return logout?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? registerLogged,
    TResult Function()? logout,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (logout != null) {
      return logout();
    }
    return orElse();
  }
}

abstract class UserLogout implements UserState {
  const factory UserLogout() = _$UserLogout;
}

/// @nodoc
abstract class _$$PasswordUpdatedCopyWith<$Res> {
  factory _$$PasswordUpdatedCopyWith(
          _$PasswordUpdated value, $Res Function(_$PasswordUpdated) then) =
      __$$PasswordUpdatedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PasswordUpdatedCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$PasswordUpdated>
    implements _$$PasswordUpdatedCopyWith<$Res> {
  __$$PasswordUpdatedCopyWithImpl(
      _$PasswordUpdated _value, $Res Function(_$PasswordUpdated) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PasswordUpdated implements PasswordUpdated {
  const _$PasswordUpdated();

  @override
  String toString() {
    return 'UserState.passwordUpdated()';
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? loading,
    TResult? Function()? logged,
    TResult? Function()? registerLogged,
    TResult? Function()? logout,
    TResult? Function()? passwordUpdated,
    TResult? Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return passwordUpdated?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? registerLogged,
    TResult Function()? logout,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (passwordUpdated != null) {
      return passwordUpdated();
    }
    return orElse();
  }
}

abstract class PasswordUpdated implements UserState {
  const factory PasswordUpdated() = _$PasswordUpdated;
}

/// @nodoc
abstract class _$$UserErrorCopyWith<$Res> {
  factory _$$UserErrorCopyWith(
          _$UserError value, $Res Function(_$UserError) then) =
      __$$UserErrorCopyWithImpl<$Res>;
  @useResult
  $Res call({String? error, List<String>? errors, Object? data});
}

/// @nodoc
class __$$UserErrorCopyWithImpl<$Res>
    extends _$UserStateCopyWithImpl<$Res, _$UserError>
    implements _$$UserErrorCopyWith<$Res> {
  __$$UserErrorCopyWithImpl(
      _$UserError _value, $Res Function(_$UserError) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = freezed,
    Object? errors = freezed,
    Object? data = freezed,
  }) {
    return _then(_$UserError(
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
      errors: freezed == errors
          ? _value._errors
          : errors // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      data: freezed == data ? _value.data : data,
    ));
  }
}

/// @nodoc

class _$UserError implements UserError {
  const _$UserError({this.error, final List<String>? errors, this.data})
      : _errors = errors;

  @override
  final String? error;
  final List<String>? _errors;
  @override
  List<String>? get errors {
    final value = _errors;
    if (value == null) return null;
    if (_errors is EqualUnmodifiableListView) return _errors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final Object? data;

  @override
  String toString() {
    return 'UserState.error(error: $error, errors: $errors, data: $data)';
  }

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UserErrorCopyWith<_$UserError> get copyWith =>
      __$$UserErrorCopyWithImpl<_$UserError>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>(
    TResult? Function()? $default, {
    TResult? Function()? loading,
    TResult? Function()? logged,
    TResult? Function()? registerLogged,
    TResult? Function()? logout,
    TResult? Function()? passwordUpdated,
    TResult? Function(String? error, List<String>? errors, Object? data)? error,
  }) {
    return error?.call(this.error, errors, data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>(
    TResult Function()? $default, {
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? registerLogged,
    TResult Function()? logout,
    TResult Function()? passwordUpdated,
    TResult Function(String? error, List<String>? errors, Object? data)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error, errors, data);
    }
    return orElse();
  }
}

abstract class UserError implements UserState {
  const factory UserError(
      {final String? error,
      final List<String>? errors,
      final Object? data}) = _$UserError;

  String? get error;
  List<String>? get errors;
  Object? get data;
  @JsonKey(ignore: true)
  _$$UserErrorCopyWith<_$UserError> get copyWith =>
      throw _privateConstructorUsedError;
}
